/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


#pragma mark - NativeVoskVoskOptions

template <typename P0, typename P1>
struct NativeVoskVoskOptions {
  P0 grammar;
  P1 timeout;
  bool operator==(const NativeVoskVoskOptions &other) const {
    return grammar == other.grammar && timeout == other.timeout;
  }
};

template <typename T>
struct NativeVoskVoskOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.grammar)>(rt, value.getProperty(rt, "grammar"), jsInvoker),
      bridging::fromJs<decltype(types.timeout)>(rt, value.getProperty(rt, "timeout"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array grammarToJs(jsi::Runtime &rt, decltype(types.grammar) value) {
    return bridging::toJs(rt, value);
  }
  static double timeoutToJs(jsi::Runtime &rt, decltype(types.timeout) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.grammar) {
      result.setProperty(rt, "grammar", bridging::toJs(rt, value.grammar.value(), jsInvoker));
    }
    if (value.timeout) {
      result.setProperty(rt, "timeout", bridging::toJs(rt, value.timeout.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeVoskCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "Vosk";

protected:
  NativeVoskCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeVoskCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["loadModel"] = MethodMetadata {.argCount = 1, .invoker = __loadModel};
    methodMap_["unload"] = MethodMetadata {.argCount = 0, .invoker = __unload};
    methodMap_["start"] = MethodMetadata {.argCount = 1, .invoker = __start};
    methodMap_["stop"] = MethodMetadata {.argCount = 0, .invoker = __stop};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
    eventEmitterMap_["onResult"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    eventEmitterMap_["onPartialResult"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    eventEmitterMap_["onFinalResult"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    eventEmitterMap_["onError"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    eventEmitterMap_["onTimeout"] = std::make_shared<AsyncEventEmitter<>>();
  }
  
  template <typename OnResultType> void emitOnResult(OnResultType value) {
    static_assert(bridging::supportsFromJs<OnResultType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*eventEmitterMap_["onResult"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnPartialResultType> void emitOnPartialResult(OnPartialResultType value) {
    static_assert(bridging::supportsFromJs<OnPartialResultType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*eventEmitterMap_["onPartialResult"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnFinalResultType> void emitOnFinalResult(OnFinalResultType value) {
    static_assert(bridging::supportsFromJs<OnFinalResultType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*eventEmitterMap_["onFinalResult"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnErrorType> void emitOnError(OnErrorType value) {
    static_assert(bridging::supportsFromJs<OnErrorType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*eventEmitterMap_["onError"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  void emitOnTimeout() {
    static_cast<AsyncEventEmitter<>&>(*eventEmitterMap_["onTimeout"]).emit();
  }
private:
  static jsi::Value __loadModel(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::loadModel) == 2,
      "Expected loadModel(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::loadModel,  static_cast<NativeVoskCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __unload(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::unload) == 1,
      "Expected unload(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::unload,  static_cast<NativeVoskCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __start(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::start) == 2,
      "Expected start(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::start,  static_cast<NativeVoskCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asObject(rt)));
  }

  static jsi::Value __stop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::stop) == 1,
      "Expected stop(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::stop,  static_cast<NativeVoskCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeVoskCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeVoskCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};

} // namespace facebook::react
